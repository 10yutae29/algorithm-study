# Stack 1

:물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조

**선형구조**: 자료 간의 관계가 1대 1의 관계를 가짐 (Stack은 선형 구조)

비선형구조: 자료 간의 관계가 1대 N의 관계를 가짐 (예: 트리)

<br>

### Stack

- 스택에 자료를 삽입하고나, 스택에서 자료를 꺼낼 수 있음

- 마지막에 삽입한 자료를 가장 먼저 꺼냄

  이를 후입선출(LIFO, Last-In-First-Out)이라고 부름

- 자료를 선형으로 저장할 저장소가 필요함 (파이썬에서는 리스트로 구현)

- 마지막에 삽입된 원소의 위치를 top이라 부름

<br>

### Stack의 연산

`삽입`, `삭제`, `isEmpty`, `peek` (탑에 있는 원소를 반환하는 연산)

<br>

### 고려사항

- 리스트의 크기를 변경하는 작업은 내부적으로 overhead 발생 작업으로 많은 시간이 소요

​	→ 미리 크기를 정해놓고 사용하는 방법

​	→ 저장소를 동적으로 할당하여 스택을 구현

<br>

## Stack 의 응용



## Menoization 피보나치 수열

![image-20220808210958791](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20220808210958791.png)

**피보나치 수열을 구하는 함수의 알고리즘**
```python
def fibo(n):
	if n<2:
        return n
    else:
        return fibo(n-1) + fibo(n-2)
```

=> 하지만 엄청난 중복 호출이 존재함

=> 그래서 메모이제이션!

<br>

### Memoization

: 메모리 넣기. 기억되어야 할 것. 기억하기. 암기하기의 뜻

- 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 계산치않도록하는 기술
- DP(동적계획법)의 핵심이 되는 기술 

``` python
#momo를 위한 리스트 생성하고,
#memo[0]을 0으로 memo[1]은 1로 초기화 한다.

def fibo1(n):
    global memo
    if n>=2 and len(memo) <= n:
        memo.append(fibo1(n-1) + fibo1(n-2)))
      return memo[n]
memo = [0,1]
```

- fibo(n)의 값을 계산하자마자 저장
- 만약 기존에 계산하여 저장된 값이 있을 경우 다시 계산하지 않겠다는 알고리즘

<br>

## 동적 계획법

: 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결

- 문제를 부분문제로 분할
- 가장 작은 부분 문제부터 해를 구함
- 결과 값들을 리스트에 저장해서 최상위 값을 해결

**피보나치 수를 DP에 적용한 예시**

```python
def fibo2(n):
    f = [0,1]
    for i in range(2, n+1):
        f.append(f[i-1] + f[i-2])
    return f[n]
```


